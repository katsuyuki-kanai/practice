# TCPの仕組み

## 目次
1. [TCPとは](#tcpとは)
2. [TCPとUDPの違い](#tcpとudpの違い)
3. [TCPの特徴](#tcpの特徴)
4. [TCPヘッダーの構造](#tcpヘッダーの構造)
5. [3ウェイハンドシェイク](#3ウェイハンドシェイク)
6. [データ転送の仕組み](#データ転送の仕組み)
7. [4ウェイハンドシェイク](#4ウェイハンドシェイク)
8. [フロー制御と輻輳制御](#フロー制御と輻輳制御)
9. [再送制御](#再送制御)
10. [まとめ](#まとめ)

---

## TCPとは

### TCP (Transmission Control Protocol)
- **信頼性の高い**データ通信を実現するプロトコル
- インターネット通信の基盤となる重要なプロトコル
- OSI参照モデルの**トランスポート層**（第4層）に位置

### TCPが使われる場面
- **Webブラウジング**（HTTP/HTTPS）
- **メール送受信**（SMTP、POP3、IMAP）
- **ファイル転送**（FTP、SFTP）
- **SSH接続**
- **データベース接続**

### なぜTCPが必要なのか？

インターネットの通信は**不安定**です：

```
送信側                         受信側
  |                              |
  |--[パケット1]---------------->|  ✓ 到着
  |--[パケット2]----X            |  ✗ 消失
  |--[パケット3]---------------->|  ✓ 到着（順序が逆）
  |--[パケット4]---------破損--->|  ✗ データ破損
```

**TCPがあれば：**
- 消失したパケットを**再送**
- 順序がバラバラでも**正しい順序で復元**
- 破損したデータを**検出して再送要求**

---

## TCPとUDPの違い

インターネット通信には主に2つのプロトコルがあります。

| 項目 | TCP | UDP |
|-----|-----|-----|
| 正式名称 | Transmission Control Protocol | User Datagram Protocol |
| 信頼性 | **高い**（到達保証あり） | **低い**（到達保証なし） |
| 接続 | **コネクション型**（事前接続） | **コネクションレス型** |
| 速度 | やや遅い | **高速** |
| 順序保証 | **あり** | なし |
| エラー訂正 | **あり** | 最小限 |
| オーバーヘッド | 大きい | 小さい |
| 用途 | Web、メール、ファイル転送 | 動画配信、音声通話、DNS |

### どちらを使うべきか？

**TCPを使う場合：**
```
✅ データの正確性が重要
✅ 欠損があってはいけない
✅ 順序が重要

例：
- 銀行の取引データ
- ファイルのダウンロード
- チャットメッセージ
```

**UDPを使う場合：**
```
✅ 速度が最優先
✅ 多少のデータ欠損は許容できる
✅ リアルタイム性が重要

例：
- ライブ配信（YouTube Live）
- オンラインゲーム
- IP電話（VoIP）
```

---

## TCPの特徴

TCPには5つの重要な特徴があります。

### 1. コネクション指向
通信を始める前に、送信側と受信側が**接続を確立**します。

```
電話をかけるイメージ：
1. 電話をかける（接続要求）
2. 相手が出る（接続確立）
3. 会話する（データ転送）
4. 電話を切る（接続終了）
```

### 2. 信頼性の保証
- すべてのデータが**確実に届く**
- **順序通り**に届く
- **重複なし**で届く

### 3. フロー制御
受信側の処理能力に合わせて、送信速度を調整します。

```
受信側のバッファ：
┌─────────────┐
│█████████░░░│ 75%使用中
└─────────────┘
     ↓
送信側に「あと25%分送れるよ」と通知
```

### 4. 輻輳制御
ネットワークの混雑状況に応じて、送信量を調整します。

```
ネットワークが混雑
  ↓
パケットロスが発生
  ↓
送信速度を下げる
  ↓
徐々に速度を上げていく
```

### 5. エラー検出と再送
データが破損したり、消失したら**自動的に再送**します。

---

## TCPヘッダーの構造

TCPヘッダーには、通信制御に必要な情報が詰まっています。

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Offset| Res |     Flags       |            Window             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 主要なフィールド

| フィールド | サイズ | 説明 |
|-----------|-------|------|
| **送信元ポート** | 16bit | 送信側のポート番号 |
| **宛先ポート** | 16bit | 受信側のポート番号 |
| **シーケンス番号** | 32bit | 送信データの位置を示す |
| **確認応答番号** | 32bit | 次に受信したいデータの位置 |
| **フラグ** | 9bit | 制御フラグ（後述） |
| **ウィンドウサイズ** | 16bit | 受信可能なデータ量 |
| **チェックサム** | 16bit | エラー検出用 |

### TCPフラグ（重要）

| フラグ | 名称 | 意味 |
|-------|------|------|
| **SYN** | Synchronize | 接続要求 |
| **ACK** | Acknowledgment | 確認応答 |
| **FIN** | Finish | 接続終了 |
| **RST** | Reset | 接続リセット |
| **PSH** | Push | データを即座に送信 |
| **URG** | Urgent | 緊急データ |

---

## 3ウェイハンドシェイク

TCPで通信を開始する際の**接続確立手順**です。

### 接続確立の流れ

```
クライアント                           サーバー
   (状態: CLOSED)                    (状態: LISTEN)
      |                                   |
      |---(1) SYN------------------------>|
      |    Seq=100                         |
      |    (状態: SYN-SENT)               (状態: SYN-RECEIVED)
      |                                   |
      |<--(2) SYN-ACK---------------------|
      |    Seq=300, Ack=101               |
      |                                   |
      |---(3) ACK------------------------>|
      |    Seq=101, Ack=301               |
   (状態: ESTABLISHED)              (状態: ESTABLISHED)
      |                                   |
      |========接続確立完了===============|
```

### 詳細な説明

**ステップ1：SYN（接続要求）**
```
クライアント → サーバー

TCPヘッダ：
- SYNフラグ: 1
- シーケンス番号: 100（初期値をランダムに決定）
- ウィンドウサイズ: 65535

意味：「接続したいです。私のシーケンス番号は100から始めます」
```

**ステップ2：SYN-ACK（接続許可）**
```
サーバー → クライアント

TCPヘッダ：
- SYNフラグ: 1
- ACKフラグ: 1
- シーケンス番号: 300（サーバー側の初期値）
- 確認応答番号: 101（クライアントの次のシーケンス番号）
- ウィンドウサイズ: 65535

意味：「接続OKです。101番からデータを送ってください。
      私のシーケンス番号は300から始めます」
```

**ステップ3：ACK（接続確立）**
```
クライアント → サーバー

TCPヘッダ：
- ACKフラグ: 1
- シーケンス番号: 101
- 確認応答番号: 301（サーバーの次のシーケンス番号）

意味：「了解しました。301番からデータを送ってください」
```

### なぜ3回必要なのか？

**2回だとダメな理由：**
```
古い接続要求が遅延して届いた場合：

1. クライアント → サーバー: SYN（古いパケット）
2. サーバー → クライアント: SYN-ACK

→ サーバーは接続確立したと思って待機
→ クライアントは応答しない（古いパケットと認識）
→ サーバーのリソースが無駄に消費される
```

**3回あれば：**
```
3回目のACKで、クライアントが本当に接続を
望んでいることを確認できる
```

---

## データ転送の仕組み

接続確立後、実際にデータを転送する流れを見てみましょう。

### 基本的なデータ転送

```
クライアント                           サーバー
      |                                   |
      |---(1) データ送信------------------>|
      |    Seq=101, Len=100               |
      |    データ: "Hello, Server!"        |
      |                                   |
      |<--(2) ACK確認応答------------------|
      |    Ack=201                         |
      |    (101+100=201を受信待ち)        |
      |                                   |
      |---(3) データ送信------------------>|
      |    Seq=201, Len=50                |
      |                                   |
      |<--(4) ACK確認応答------------------|
      |    Ack=251                         |
```

### シーケンス番号の役割

**送信側：**
```
送信データ: "ABCDEFGHIJ" (10バイト)

Seq=1000で送信
→ 次は Seq=1010で送信
→ 次は Seq=1020で送信
```

**受信側：**
```
Seq=1020を受信 → まだ1010が来ていない！
→ 1010を再送要求
→ 1010を受信
→ 正しい順序に並べ替え: 1000, 1010, 1020
```

### ウィンドウサイズとスライディングウィンドウ

受信側が一度に受け取れるデータ量を**ウィンドウサイズ**で通知します。

```
ウィンドウサイズ = 4KB の場合：

送信側                           受信側
  |                                |
  |--[1KB]------------------------->| 受信OK
  |--[1KB]------------------------->| 受信OK
  |--[1KB]------------------------->| 受信OK
  |--[1KB]------------------------->| 受信OK（バッファ満杯）
  |                                |
  | ← ウィンドウサイズ: 0 ----------|
  |   （送信停止）                   |
  |                                | アプリがデータ処理
  |                                | バッファに空きができた
  | ← ウィンドウサイズ: 2KB ---------|
  |   （再開）                      |
  |--[1KB]------------------------->|
  |--[1KB]------------------------->|
```

---

## 4ウェイハンドシェイク

通信を終了する際の**接続終了手順**です。

### 接続終了の流れ

```
クライアント                           サーバー
(状態: ESTABLISHED)               (状態: ESTABLISHED)
      |                                   |
      |---(1) FIN------------------------>|
      |    Seq=1000                        |
   (状態: FIN-WAIT-1)                (状態: CLOSE-WAIT)
      |                                   |
      |<--(2) ACK-------------------------|
      |    Ack=1001                        |
   (状態: FIN-WAIT-2)                     |
      |                                   |
      |                             サーバー側の
      |                             データ送信完了
      |                                   |
      |<--(3) FIN-------------------------|
      |    Seq=2000                        |
      |                             (状態: LAST-ACK)
   (状態: TIME-WAIT)                      |
      |                                   |
      |---(4) ACK------------------------>|
      |    Ack=2001                        |
      |                             (状態: CLOSED)
      |                                   |
   (2MSL待機後)                           |
   (状態: CLOSED)                         |
```

### 詳細な説明

**ステップ1：FIN（終了要求）**
```
クライアント → サーバー
「もう送るデータはありません」
```

**ステップ2：ACK（確認応答）**
```
サーバー → クライアント
「終了要求を受け取りました。でも、まだ送りたいデータがあるかも」
```

**ステップ3：FIN（終了要求）**
```
サーバー → クライアント
「こちらも送るデータがなくなりました」
```

**ステップ4：ACK（確認応答）**
```
クライアント → サーバー
「了解しました。接続を閉じます」
```

### なぜ4回必要なのか？

TCPは**全二重通信**（両方向同時に通信可能）なので：

```
クライアント → サーバー の通信終了 (FIN+ACK)
サーバー → クライアント の通信終了 (FIN+ACK)

合計4回のやり取りが必要
```

### TIME-WAIT状態の意味

最後のACKを送った後、クライアントは**2MSL**（約1〜4分）待機します。

**理由：**
```
もし最後のACKが消失したら？
  ↓
サーバーはFINを再送する
  ↓
クライアントが即座にCLOSEDになっていると
再送されたFINに応答できない
  ↓
TIME-WAIT状態で待機して、再送に対応できるようにする
```

---

## フロー制御と輻輳制御

### フロー制御

**目的：** 受信側のバッファがあふれないように制御

```
受信側のバッファ容量: 64KB

┌──────────────────────────────────┐
│████████████████████████░░░░░░░░│ 75%使用中
└──────────────────────────────────┘
        ↓
送信側に「残り16KB受信可能」と通知
        ↓
送信側は16KB以下のデータを送信
```

**仕組み：**
- **ウィンドウサイズ**で受信可能量を通知
- 送信側はこの範囲内でデータを送信

### 輻輳制御

**目的：** ネットワークの混雑を防ぐ

#### スロースタート
```
最初は少量から始めて、徐々に増やす

送信量:
1 → 2 → 4 → 8 → 16 → 32 → 64 (KB)
        ↑ 指数的に増加
```

#### 輻輳回避
```
ある閾値を超えたら、ゆっくり増やす

送信量:
64 → 65 → 66 → 67 → 68 (KB)
        ↑ 線形に増加
```

#### 高速再送・高速リカバリ
```
パケットロス検出
  ↓
送信量を半分に減らす
  ↓
徐々に回復
```

### 輻輳ウィンドウ (cwnd) の動作

```
                     パケットロス
                         ↓
送信量(KB)               ↓
  |                    /\
  |                   /  \
  |                  /    \
  |                 /      \_____ 高速リカバリ
  |                /
  |          ___/ 輻輳回避
  |        /
  |      /  スロースタート
  |    /
  |  /
  |/
  +----------------------------------→ 時間
```

---

## 再送制御

データが消失したり、順序が入れ替わったりした場合の対処方法。

### タイムアウト再送

**仕組み：**
```
送信側                           受信側
  |                                |
  |--[Seq=100]-------------------->| ✓受信
  |                                |
  |<----------[Ack=200]-------------|
  |                                |
  |--[Seq=200]-----X                | ✗消失
  |                                |
  | タイムアウト（RTOまで待つ）      |
  |                                |
  |--[Seq=200]再送----------------->| ✓受信
  |                                |
  |<----------[Ack=300]-------------|
```

**RTO（Retransmission TimeOut）の計算：**
```
RTT（Round Trip Time）を測定
  ↓
RTO = RTT + 4 × (RTTの変動)
```

### 高速再送

同じACKを**3回**受信したら、タイムアウトを待たずに再送します。

```
送信側                           受信側
  |                                |
  |--[Seq=100]-------------------->| ✓受信
  |<----------[Ack=200]-------------|
  |                                |
  |--[Seq=200]-----X                | ✗消失
  |                                |
  |--[Seq=300]-------------------->| ✓受信（順序違反）
  |<----------[Ack=200]-------------|（200を期待）
  |                                |
  |--[Seq=400]-------------------->| ✓受信（順序違反）
  |<----------[Ack=200]-------------|（200を期待）
  |                                |
  |--[Seq=500]-------------------->| ✓受信（順序違反）
  |<----------[Ack=200]-------------|（200を期待）
  |                                |
  | 同じACKを3回受信！              |
  | → 高速再送                     |
  |                                |
  |--[Seq=200]再送----------------->| ✓受信
  |<----------[Ack=600]-------------|
  |                                |（すべて受信完了）
```

---

## まとめ

### TCPの重要ポイント

✅ **信頼性の高い通信を実現**
   - データの到達保証
   - 順序保証
   - エラー検出と再送

✅ **3ウェイハンドシェイク**で接続確立
   1. SYN（接続要求）
   2. SYN-ACK（接続許可）
   3. ACK（接続確立）

✅ **シーケンス番号**でデータ管理
   - データの順序を保証
   - 重複を検出
   - 欠落を検出

✅ **フロー制御**と**輻輳制御**
   - 受信側のバッファを考慮
   - ネットワークの混雑を回避

✅ **4ウェイハンドシェイク**で接続終了
   - 両方向の通信を確実に終了

### 実際の開発での注意点

1. **ポート番号の理解**
   ```
   Webサーバー: 80 (HTTP), 443 (HTTPS)
   メールサーバー: 25 (SMTP), 110 (POP3), 143 (IMAP)
   データベース: 3306 (MySQL), 5432 (PostgreSQL)
   ```

2. **TIME-WAIT問題**
   ```
   サーバーを頻繁に再起動すると、
   「Address already in use」エラーが発生することがある
   
   原因：TIME-WAIT状態のソケットが残っている
   対策：SO_REUSEADDRオプションを使用
   ```

3. **Keep-Alive**
   ```
   HTTP/1.1以降では、TCPコネクションを再利用
   
   利点：
   - 3ウェイハンドシェイクのオーバーヘッド削減
   - レイテンシの改善
   ```

4. **接続タイムアウト**
   ```javascript
   // Node.jsの例
   const net = require('net');
   
   const client = new net.Socket();
   client.setTimeout(5000); // 5秒でタイムアウト
   
   client.connect(80, 'example.com', () => {
     console.log('接続成功');
   });
   
   client.on('timeout', () => {
     console.log('接続タイムアウト');
     client.destroy();
   });
   ```

### TCPとUDP、どちらを選ぶ？

```
データの正確性 > 速度  → TCP
速度 > データの正確性  → UDP

具体例：
- Webページの閲覧 → TCP（正確性が重要）
- ライブ配信 → UDP（速度が重要、多少の欠損は許容）
- チャット → TCP（メッセージの欠損は許されない）
- オンラインゲーム → UDP（リアルタイム性が重要）
```

### さらに学ぶために

- **RFC 793**: TCP仕様書
- **Wireshark**: パケットキャプチャツール
- **netstat**: 接続状態の確認コマンド
  ```bash
  # Windows
  netstat -ano | findstr :80
  
  # 接続状態の確認
  netstat -an | findstr ESTABLISHED
  ```
- **TCPダンプ**: Linuxでのパケット解析
  ```bash
  tcpdump -i eth0 tcp port 80
  ```

---

## 演習問題

### 問題1：基礎知識
次の空欄を埋めてください。

1. TCPの接続確立には（　　）ウェイハンドシェイクを使う
2. TCPの接続終了には（　　）ウェイハンドシェイクを使う
3. データが確実に届いたことを確認するフラグは（　　）
4. 接続要求を示すフラグは（　　）

### 問題2：シナリオ
次の状況でTCPとUDPのどちらが適切か答えてください。

1. 銀行の振込システム
2. YouTubeのライブ配信
3. メールの送信
4. オンライン対戦ゲーム

### 問題3：実践
次のコマンドを実行して、実際のTCP接続を確認してみましょう：

**Windows (PowerShell)：**
```powershell
# 現在のTCP接続を表示
netstat -ano | Select-String "TCP"

# 特定のポートの接続を確認
netstat -ano | Select-String ":443"

# 接続状態別に確認
netstat -ano | Select-String "ESTABLISHED"
```

### 問題4：計算問題
以下の条件でデータ転送にかかる時間を計算してください：

- データサイズ: 10MB
- 帯域幅: 100Mbps
- RTT（往復時間）: 20ms
- ウィンドウサイズ: 64KB

（ヒント：3ウェイハンドシェイクの時間も考慮）

---

**作成日**: 2026年2月4日  
**対象**: 新人エンジニア  
**所要時間**: 90分
