# JWT認証とセッションベース認証の比較

## 概要

Webアプリケーションにおける認証方式には、主に**セッションベース認証**と**JWT(JSON Web Token)認証**の2つのアプローチがあります。それぞれに特徴があり、用途によって使い分けることが重要です。

## セッションベース認証

### 仕組み

![セッションベース認証フロー](img/session-flow.svg)

1. ユーザーがログイン情報(ユーザー名・パスワード)を送信
2. サーバーが認証情報を検証
3. サーバーがセッションを作成し、セッションIDを発行
4. セッションIDをクッキーに保存してクライアントに返す
5. 以降のリクエストでクッキーのセッションIDを送信
6. サーバーはセッションストアでセッションIDを検証

### 特徴

#### メリット
- **セッションの即座な無効化**: サーバー側でセッションを削除すれば即座に無効化できる
- **サーバー側での完全な制御**: セッション情報をサーバーで管理するため、柔軟な制御が可能
- **セキュリティ**: セッションIDのみがクライアントに保存され、ユーザー情報はサーバー側に保持
- **シンプルな実装**: 多くのフレームワークで標準サポート

#### デメリット
- **スケーラビリティの課題**: セッション情報をサーバーに保存する必要があり、水平スケーリングが困難
- **サーバーリソースの消費**: 全セッションをメモリやデータベースに保存
- **CSRF攻撃のリスク**: クッキーベースのため、CSRF対策が必要
- **モバイルアプリでの扱いにくさ**: クッキーの管理が煩雑

### 実装例

```javascript
// Express.js での例
const session = require('express-session');

app.use(session({
  secret: 'your-secret-key',
  resave: false,
  saveUninitialized: false,
  cookie: { 
    secure: true,
    httpOnly: true,
    maxAge: 3600000 // 1時間
  }
}));

// ログイン処理
app.post('/login', (req, res) => {
  // 認証処理...
  req.session.userId = user.id;
  res.json({ message: 'ログイン成功' });
});

// 保護されたエンドポイント
app.get('/profile', (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: '未認証' });
  }
  // ユーザー情報を返す...
});
```

## JWT認証

### 仕組み

![JWT認証フロー](img/jwt-flow.svg)

1. ユーザーがログイン情報を送信
2. サーバーが認証情報を検証
3. サーバーがJWTトークンを生成(ユーザー情報をペイロードに含む)
4. トークンをクライアントに返す
5. クライアントはトークンをローカルストレージやメモリに保存
6. 以降のリクエストでAuthorizationヘッダーにトークンを含める
7. サーバーはトークンの署名を検証

### JWTの構造

![JWTの構造](img/jwt-structure.svg)

JWT は3つの部分から構成されます:

```
Header.Payload.Signature
```

- **Header**: トークンのタイプとアルゴリズム
- **Payload**: ユーザー情報やクレーム(claims)
- **Signature**: ヘッダーとペイロードの署名

例:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjM0NTYiLCJleHAiOjE2MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### 特徴

#### メリット
- **ステートレス**: サーバー側でセッション情報を保持する必要がない
- **スケーラビリティ**: 複数サーバー間で容易に認証を共有可能
- **マイクロサービスに適している**: トークンに必要な情報が含まれているため、各サービスで独立して検証可能
- **モバイルアプリに適している**: ヘッダーベースの認証で扱いやすい
- **クロスドメイン対応**: CORS設定で複数のドメインから利用可能

#### デメリット
- **トークンの即座な無効化が困難**: トークンは自己完結型のため、期限まで有効
- **トークンサイズが大きい**: ペイロードに情報を含むため、クッキーより大きい
- **XSS攻撃のリスク**: ローカルストレージに保存する場合、XSS攻撃に脆弱
- **リフレッシュトークンの管理**: アクセストークンの期限を短くする場合、リフレッシュの仕組みが必要

### 実装例

```javascript
// Express.js での例
const jwt = require('jsonwebtoken');

const SECRET_KEY = 'your-secret-key';

// ログイン処理
app.post('/login', (req, res) => {
  // 認証処理...
  const token = jwt.sign(
    { userId: user.id, email: user.email },
    SECRET_KEY,
    { expiresIn: '1h' }
  );
  res.json({ token });
});

// ミドルウェア
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: '未認証' });
  }
  
  jwt.verify(token, SECRET_KEY, (err, user) => {
    if (err) {
      return res.status(403).json({ error: '無効なトークン' });
    }
    req.user = user;
    next();
  });
};

// 保護されたエンドポイント
app.get('/profile', authenticateToken, (req, res) => {
  // req.user にトークンのペイロードが含まれる
  res.json({ userId: req.user.userId });
});
```

## アーキテクチャの違い

![アーキテクチャ比較](img/comparison-architecture.svg)

上の図は、セッションベース認証とJWT認証のアーキテクチャの違いを示しています。セッションベースでは全サーバーがセッションストアにアクセスする必要がありますが、JWTではサーバーが独立して認証を検証できます。

## 比較表

| 項目 | セッションベース | JWT |
|------|----------------|-----|
| **状態管理** | ステートフル(サーバー側で管理) | ステートレス |
| **保存場所** | サーバー(メモリ/DB) | クライアント |
| **スケーラビリティ** | 低い(セッション共有が必要) | 高い |
| **即座の無効化** | 可能 | 困難(ブラックリスト等が必要) |
| **サーバー負荷** | 高い(セッション保存) | 低い(検証のみ) |
| **トークンサイズ** | 小さい(セッションID) | 大きい(ペイロード含む) |
| **セキュリティリスク** | CSRF | XSS |
| **マイクロサービス** | 不向き | 向いている |
| **モバイルアプリ** | やや不便 | 向いている |
| **実装の複雑さ** | シンプル | やや複雑(トークン管理) |

## セキュリティのベストプラクティス

### セッションベース認証
- **HTTPS通信を使用**: クッキーを暗号化通信で送信
- **HttpOnly・Secureフラグを設定**: JavaScriptからのアクセスを防止
- **CSRF対策を実装**: CSRFトークンの使用
- **セッションタイムアウトの設定**: 適切な有効期限を設定
- **セッション固定攻撃対策**: ログイン時にセッションIDを再生成

### JWT認証
- **HTTPSを使用**: トークンの盗聴を防止
- **短い有効期限を設定**: アクセストークンは短く(15分〜1時間)
- **リフレッシュトークンの利用**: 長期間のセッション維持
- **トークンの保存場所**: HttpOnly cookieまたはメモリに保存(ローカルストレージは避ける)
- **強力な署名アルゴリズム**: HS256以上、または非対称鍵(RS256)を使用
- **ペイロードに機密情報を含めない**: JWTはデコード可能

## 使い分けの指針

### セッションベース認証が適している場合
- 単一サーバーまたは小規模なアプリケーション
- セッションの即座な無効化が重要な場合
- 伝統的なWebアプリケーション
- セキュリティを最優先する場合

### JWT認証が適している場合
- マイクロサービスアーキテクチャ
- RESTful API
- モバイルアプリケーション
- スケーラビリティが重要な場合
- 複数のサービス・ドメイン間で認証を共有する場合

## ハイブリッドアプローチ

実際のアプリケーションでは、両方の利点を組み合わせることもあります:

- **JWTをHttpOnly Cookieで送信**: XSSとCSRFの両方に対策
- **リフレッシュトークンをセッションで管理**: JWTの無効化問題に対応
- **短期JWTと長期セッション**: セキュリティとUXのバランス

```javascript
// ハイブリッドの例
app.post('/login', (req, res) => {
  // 認証処理...
  
  // 短期アクセストークン
  const accessToken = jwt.sign(
    { userId: user.id },
    ACCESS_SECRET,
    { expiresIn: '15m' }
  );
  
  // 長期リフレッシュトークン
  const refreshToken = jwt.sign(
    { userId: user.id },
    REFRESH_SECRET,
    { expiresIn: '7d' }
  );
  
  // リフレッシュトークンをDBに保存
  await saveRefreshToken(user.id, refreshToken);
  
  // HttpOnly Cookieでリフレッシュトークンを送信
  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000
  });
  
  res.json({ accessToken });
});
```

## まとめ

- **セッションベース認証**は、シンプルで制御しやすいが、スケーラビリティに課題がある
- **JWT認証**は、スケーラブルでステートレスだが、トークン管理が複雑
- 要件に応じて適切な方式を選択し、セキュリティのベストプラクティスに従うことが重要
- ハイブリッドアプローチで両方の利点を活かすことも可能

選択の際は、アプリケーションの規模、アーキテクチャ、セキュリティ要件、ユーザー体験を総合的に考慮してください。
