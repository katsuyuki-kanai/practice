# RDB（リレーショナルデータベース）の基礎概念

## 📚 この資料で学ぶこと
- データベースとは何か
- RDBの基本構造
- テーブル設計の基礎
- キーの概念

---

## 1. データベースとは

### 1.1 データベースの定義
データベース（Database）とは、**データを効率的に保存・管理・検索できるように整理された情報の集まり**です。

```
📦 データベースがない場合
├── Excel1.xlsx（顧客データ）
├── Excel2.xlsx（注文データ）
├── メモ帳.txt（在庫データ）
└── 問題: データの重複、整合性の欠如、検索が困難

📦 データベースがある場合
└── 統一されたシステム
    ├── 顧客テーブル
    ├── 注文テーブル
    └── 在庫テーブル
    → データの一元管理、高速検索、整合性の保証
```

### 1.2 データベースを使うメリット
| メリット | 説明 |
|---------|------|
| **データの永続化** | アプリケーションが終了してもデータが残る |
| **高速な検索** | インデックスによる効率的なデータ取得 |
| **データの整合性** | 制約によりおかしなデータを防ぐ |
| **同時アクセス** | 複数ユーザーが同時に操作可能 |
| **セキュリティ** | アクセス権限の設定が可能 |

---

## 2. RDB（リレーショナルデータベース）とは

### 2.1 RDBの特徴
RDBは、データを**テーブル（表）形式**で管理するデータベースです。

```
テーブル = 行（レコード）× 列（カラム）
```

### 2.2 代表的なRDBMS（リレーショナルデータベース管理システム）

| RDBMS | 特徴 | 用途 |
|-------|------|------|
| **MySQL** | オープンソース、高速 | Web開発で広く使用 |
| **PostgreSQL** | 高機能、標準SQL準拠 | エンタープライズ向け |
| **SQLite** | 軽量、ファイルベース | モバイルアプリ、小規模システム |
| **Oracle** | 高信頼性、商用 | 大規模エンタープライズ |
| **SQL Server** | Microsoft製、Windows統合 | .NET環境 |

---

## 3. テーブルの基本構造

### 3.1 テーブル、レコード、カラム

```
【usersテーブル】

+----+----------+----------------------+-----+
| id | name     | email                | age |  ← カラム（列）
+----+----------+----------------------+-----+
|  1 | 田中太郎 | tanaka@example.com   |  25 |  ← レコード（行）
|  2 | 佐藤花子 | sato@example.com     |  30 |  ← レコード（行）
|  3 | 鈴木一郎 | suzuki@example.com   |  28 |  ← レコード（行）
+----+----------+----------------------+-----+

- テーブル: データを格納する「表」
- カラム（列）: データの属性（id, name, email, age）
- レコード（行）: 1件分のデータ
- フィールド: 行と列が交差する1つのセル
```

### 3.2 データ型
カラムには「データ型」を指定します。

| カテゴリ | データ型 | 説明 | 例 |
|---------|---------|------|-----|
| **数値** | INT, INTEGER | 整数 | 1, 100, -50 |
| | DECIMAL(M,N) | 固定小数点 | 1234.56 |
| | FLOAT, DOUBLE | 浮動小数点 | 3.14159 |
| **文字列** | VARCHAR(N) | 可変長文字列 | 'Hello' |
| | CHAR(N) | 固定長文字列 | 'ABC' |
| | TEXT | 長い文字列 | 記事本文など |
| **日付/時刻** | DATE | 日付 | '2026-02-03' |
| | DATETIME | 日時 | '2026-02-03 10:30:00' |
| | TIMESTAMP | タイムスタンプ | 自動更新される日時 |
| **真偽値** | BOOLEAN | true/false | TRUE, FALSE |

---

## 4. キーの概念

### 4.1 主キー（Primary Key）
テーブル内で**各レコードを一意に識別**するためのカラム。

```sql
-- 主キーの特徴
-- ✅ 重複不可（UNIQUE）
-- ✅ NULL不可（NOT NULL）
-- ✅ 1テーブルに1つだけ

【usersテーブル】
+----+----------+  ← id が主キー
| id | name     |
+----+----------+
|  1 | 田中太郎 |  ✅ OK
|  2 | 佐藤花子 |  ✅ OK
|  1 | 鈴木一郎 |  ❌ NG（idが重複）
+----+----------+
```

### 4.2 外部キー（Foreign Key）
他のテーブルの主キーを参照し、**テーブル間の関連を定義**するカラム。

```
【usersテーブル】              【ordersテーブル】
+----+----------+              +----+---------+--------+
| id | name     |              | id | user_id | amount |
+----+----------+              +----+---------+--------+
|  1 | 田中太郎 | ←────────────|  1 |    1    |  5000  |
|  2 | 佐藤花子 | ←────────────|  2 |    2    |  3000  |
+----+----------+         └────|  3 |    1    |  2000  |
                               +----+---------+--------+
                               
user_id は users.id を参照する「外部キー」
→ 存在しないユーザーの注文は登録できない（参照整合性）
```

---

## 5. テーブル間の関係（リレーション）

### 5.1 1対1（One-to-One）
1つのレコードが、他のテーブルの1つのレコードと対応。

```
【usersテーブル】           【profilesテーブル】
+----+----------+           +----+---------+----------+
| id | name     |           | id | user_id | bio      |
+----+----------+           +----+---------+----------+
|  1 | 田中太郎 | ←─────────|  1 |    1    | 趣味は.. |
|  2 | 佐藤花子 | ←─────────|  2 |    2    | 仕事は.. |
+----+----------+           +----+---------+----------+

例: ユーザーとプロフィール
```

### 5.2 1対多（One-to-Many）
1つのレコードが、他のテーブルの複数のレコードと対応。

```
【usersテーブル】           【ordersテーブル】
+----+----------+           +----+---------+--------+
| id | name     |           | id | user_id | amount |
+----+----------+           +----+---------+--------+
|  1 | 田中太郎 | ←─────┬───|  1 |    1    |  5000  |
|  2 | 佐藤花子 |       └───|  3 |    1    |  2000  |
+----+----------+ ←─────────|  2 |    2    |  3000  |
                            +----+---------+--------+

例: ユーザーと注文（1人のユーザーが複数の注文）
```

### 5.3 多対多（Many-to-Many）
複数のレコードが、複数のレコードと対応。**中間テーブル**が必要。

```
【studentsテーブル】    【student_coursesテーブル】    【coursesテーブル】
+----+--------+         +------------+-----------+     +----+----------+
| id | name   |         | student_id | course_id |     | id | name     |
+----+--------+         +------------+-----------+     +----+----------+
|  1 | 山田   |←────────|     1      |     1     |────→|  1 | 数学     |
|  2 | 田中   |←──┬─────|     1      |     2     |─┬──→|  2 | 英語     |
+----+--------+   │     |     2      |     2     |─┘   +----+----------+
                  └─────|     2      |     1     |────→
                        +------------+-----------+

例: 学生と講座（学生は複数の講座を受講、講座には複数の学生）
```

---

## 6. 正規化の基礎

### 6.1 正規化とは
データの**重複を排除**し、**整合性を保つ**ためのテーブル設計手法です。

正規化には段階があり、通常は**第三正規形（3NF）**まで行います。

```
非正規形 → 第一正規形 → 第二正規形 → 第三正規形 → ...
(繰り返しあり)  (繰り返し除去)  (部分関数従属除去)  (推移的関数従属除去)
```

---

## 6.2 サンプルデータの定義

これから正規化を学ぶために、以下のサンプルデータを使用します。
**全ての正規化段階で同じデータを使用**し、構造だけを変えていきます。

### 📝 注文内容（これを様々な形で表現していきます）

```
注文1: 田中太郎さん（東京都渋谷区）が、りんご(100円)を注文
注文2: 田中太郎さん（東京都渋谷区）が、みかん(150円)を注文
注文3: 佐藤花子さん（大阪府大阪市）が、りんご(100円)を注文

💡 シンプルに学ぶため「1つの注文=1つの商品」としています
```

---

## 6.3 データ異常の問題

正規化されていないテーブルでは、以下の「データ異常」が発生します。

### 非正規形の例
```
【注文テーブル】- 問題のある設計
+--------+----------+------------------+----------+------+
| 注文ID | 顧客名   | 住所             | 商品名   | 価格 |
+--------+----------+------------------+----------+------+
|   1    | 田中太郎 | 東京都渋谷区     | りんご   | 100  |
|   2    | 田中太郎 | 東京都渋谷区     | みかん   | 150  |
|   3    | 佐藤花子 | 大阪府大阪市     | りんご   | 100  |
+--------+----------+------------------+----------+------+
```

### ❌ データ異常の種類

#### 1. 更新異常（Update Anomaly）
```
問題: 田中太郎の住所を変更する場合
→ 複数行（注文ID=1, 2）を更新する必要がある
→ 更新漏れが発生するリスク

UPDATE 注文 SET 住所 = '東京都新宿区' 
WHERE 顧客名 = '田中太郎';  -- 複数行が対象
```

#### 2. 挿入異常（Insert Anomaly）
```
問題: まだ注文していない顧客を登録できない
→ 顧客情報は注文テーブルに含まれているため
→ 顧客マスタが作れない

-- これができない！
INSERT INTO 注文 (顧客名, 住所) 
VALUES ('鈴木一郎', '愛知県名古屋市');
-- 商品名, 価格 が NULL になってしまう
```

#### 3. 削除異常（Delete Anomaly）
```
問題: 佐藤花子の注文をキャンセルした場合
→ 佐藤花子の顧客情報も一緒に消えてしまう

DELETE FROM 注文 WHERE 注文ID = 3;
-- 佐藤花子の情報が完全に失われる
```

#### 4. 商品情報の重複
```
問題: 商品名と価格が一緒に保存されている
→ 「りんご」の価格が複数行に重複（注文ID=1と3）
→ りんごの価格変更時に複数行を更新する必要がある
→ 更新漏れで価格の不整合が発生する可能性

-- りんごの価格を変更する場合
UPDATE 注文 SET 価格 = 120 WHERE 商品名 = 'りんご';
-- 複数の注文レコードが対象になる
```

---

## 6.4 第一正規形（1NF）

### 定義
- **繰り返しグループを排除**
- **各セルに1つの値のみ**格納

### 今回のデータについて

💡 **今回のサンプルデータはすでに第一正規形です**

```
【第一正規形】← 各セルに1つの値のみ
+--------+----------+------------------+----------+------+
| 注文ID | 顧客名   | 住所             | 商品名   | 価格 |
+--------+----------+------------------+----------+------+
|   1    | 田中太郎 | 東京都渋谷区     | りんご   | 100  |
|   2    | 田中太郎 | 東京都渋谷区     | みかん   | 150  |
|   3    | 佐藤花子 | 大阪府大阪市     | りんご   | 100  |
+--------+----------+------------------+----------+------+

主キー: 注文ID（各注文を一意に識別）

✅ 各列に1つの値のみ（カンマ区切りなどがない）
✅ 繰り返しグループがない

しかし、まだ問題があります:
❌ 田中太郎の住所が2回出現（顧客情報の重複）
❌ りんごの価格が2回出現（商品情報の重複）
```

### 第一正規形の条件
- ✅ 各列に1つの値のみ（原子性）
- ✅ 配列や繰り返しグループがない
- ✅ 行の順序に依存しない
- ✅ 各行が主キーで一意に識別できる

---

## 6.5 第二正規形（2NF）

### 定義
- **第一正規形である**
- **部分関数従属を排除**（複合主キーの一部だけで決まる列をなくす）

### 今回のケースでは？

💡 **今回は主キーが単一（注文IDのみ）なので、部分関数従属は発生しません**

しかし、**商品情報の重複**を解消するため、テーブルを分割します。

### 正規化の手順

### 正規化の手順

💡 **引き続き同じデータを使います！**

```
【第一正規形の状態】← 商品情報が重複している
+--------+----------+------------------+----------+------+
| 注文ID | 顧客名   | 住所             | 商品名   | 価格 |
+--------+----------+------------------+----------+------+
|   1    | 田中太郎 | 東京都渋谷区     | りんご   | 100  |
|   2    | 田中太郎 | 東京都渋谷区     | みかん   | 150  |
|   3    | 佐藤花子 | 大阪府大阪市     | りんご   | 100  |  ← りんごの価格が重複
+--------+----------+------------------+----------+------+

問題点の分析:
- 商品名「りんご」と価格「100」が2行に重複（注文ID=1と3）
- りんごの価格を変更する場合、複数行を更新する必要がある
- 商品情報（商品名と価格）は注文とは独立した情報

↓ 商品情報を別テーブルに分割

【第二正規形】

【商品テーブル】← 商品マスタ（新規作成）
主キー: 商品ID
+--------+----------+------+
| 商品ID | 商品名   | 価格 |
+--------+----------+------+
|   1    | りんご   | 100  |  ← 1回だけ！
|   2    | みかん   | 150  |
+--------+----------+------+

【注文テーブル】← 注文情報（商品IDで参照）
主キー: 注文ID
外部キー: 商品ID
+--------+--------+----------+------------------+
| 注文ID | 商品ID | 顧客名   | 住所             |
+--------+--------+----------+------------------+
|   1    |   1    | 田中太郎 | 東京都渋谷区     |
|   2    |   2    | 田中太郎 | 東京都渋谷区     |  ← まだ顧客情報が重複
|   3    |   1    | 佐藤花子 | 大阪府大阪市     |
+--------+--------+----------+------------------+

改善点:
✅ 商品情報は 商品テーブル に1回だけ
✅ りんごの価格変更は1箇所を更新すればOK
✅ 注文テーブルは商品IDで商品を参照

まだ問題あり:
❌ 顧客情報（顧客名、住所）が重複している → 第三正規形で解消
```

---

## 6.6 第三正規形（3NF）

### 定義
- **第二正規形である**
- **推移的関数従属を排除**（主キー以外の列で他の列が決まる状態をなくす）

### 推移的関数従属とは？
主キーを経由して間接的に決まる列のことです。

```
主キー → 非キー列A → 非キー列B
  ↓          ↓          ↓
これで   この列が    この列が決まる（推移的）
決まる   決まって

例: 注文ID → 顧客ID → 顧客名
    注文ID → 顧客ID → 住所
```

### 正規化の手順

💡 **同じデータで最後の仕上げです！**

```
【第二正規形の状態】← 注文テーブルに注目

【注文テーブル】
主キー: 注文ID
外部キー: 商品ID
+--------+--------+----------+------------------+
| 注文ID | 商品ID | 顧客名   | 住所             |
+--------+--------+----------+------------------+
|   1    |   1    | 田中太郎 | 東京都渋谷区     |
|   2    |   2    | 田中太郎 | 東京都渋谷区     |  ← 顧客情報が重複
|   3    |   1    | 佐藤花子 | 大阪府大阪市     |
+--------+--------+----------+------------------+

問題点の分析:
- 田中太郎の顧客名と住所が2行に重複（注文ID=1と2）
- 同じ顧客が複数回注文すると、顧客情報が何度も重複する
- 顧客の住所変更時に、複数の注文レコードを更新する必要がある
- 注文していない顧客を登録できない

推移的関数従属:
  注文ID → 顧客名 → 住所
  （実際には、顧客名で顧客が特定されれば住所が決まる）
  
  より正確には、顧客IDを導入して:
  注文ID → 顧客ID → 顧客名
  注文ID → 顧客ID → 住所

↓ 顧客情報を別テーブルに分割して推移的関数従属を解消

【第三正規形】

【顧客テーブル】← 顧客マスタ
主キー: 顧客ID
+--------+----------+------------------+
| 顧客ID | 顧客名   | 住所             |
+--------+----------+------------------+
|  101   | 田中太郎 | 東京都渋谷区     |  ← 1回だけ！
|  102   | 佐藤花子 | 大阪府大阪市     |
+--------+----------+------------------+

【注文テーブル】← 注文情報（顧客情報は含まない）
主キー: 注文ID
外部キー: 顧客ID, 商品ID
+--------+--------+--------+
| 注文ID | 顧客ID | 商品ID |
+--------+--------+--------+
|   1    |  101   |   1    |  ← 顧客101がりんご
|   2    |  101   |   2    |  ← 顧客101がみかん
|   3    |  102   |   1    |  ← 顧客102がりんご
+--------+--------+--------+

【商品テーブル】← 商品マスタ（第二正規形から変わらず）
主キー: 商品ID
+--------+----------+------+
| 商品ID | 商品名   | 価格 |
+--------+----------+------+
|   1    | りんご   | 100  |
|   2    | みかん   | 150  |
+--------+----------+------+

改善点:
✅ 顧客情報は 顧客テーブル に1箇所だけ
✅ 商品情報は 商品テーブル に1箇所だけ
✅ 顧客の住所変更は1箇所を更新すればOK
✅ 商品の価格変更は1箇所を更新すればOK
✅ 注文のない顧客も 顧客テーブル に登録可能
✅ 推移的関数従属が解消された
✅ データの重複が完全になくなった

📌 元のデータとの対応を確認:
- 注文1：田中太郎（顧客ID=101）が りんご（商品ID=1）
- 注文2：田中太郎（顧客ID=101）が みかん（商品ID=2）
- 注文3：佐藤花子（顧客ID=102）が りんご（商品ID=1）
```
|    2     |     102     | 2026-01-15 |
|    3     |     101     | 2026-02-01 |  ← customer_idのみ保持
+----------+-------------+------------+

【productsテーブル】← 商品マスタ
主キー: product_id
+------------+---------------+-------+
| product_id | product_name  | price |
+------------+---------------+-------+
|      1     | りんご        |  100  |
|      2     | みかん        |  150  |
|      3     | バナナ        |  200  |
+------------+---------------+-------+

【order_detailsテーブル】← 注文明細
主キー: detail_id
外部キー: order_id, product_id
+-----------+----------+------------+----------+
| detail_id | order_id | product_id | quantity |
+-----------+----------+------------+----------+
|     1     |    1     |      1     |    2     |
|     2     |    1     |      2     |    1     |
|     3     |    2     |      1     |    3     |
|     4     |    2     |      3     |    1     |
|     5     |    3     |      1     |    1     |
+-----------+----------+------------+----------+

改善点:
✅ 顧客情報は customers テーブルに1箇所だけ
✅ 顧客の住所変更は1箇所を更新すればOK
✅ 注文のない顧客も customers テーブルに登録可能
✅ 推移的関数従属が解消された
```

---

## 6.6 正規化のメリットとデメリット

### ✅ メリット

| メリット | 説明 |
|---------|------|
| **データの一貫性** | 同じ情報が1箇所にのみ存在 |
| **更新が簡単** | 1箇所を更新すれば全体に反映 |
| **ストレージ効率** | 重複データがないため容量削減 |
| **データの整合性** | 矛盾したデータが発生しにくい |
| **保守性向上** | テーブル構造が論理的で理解しやすい |

### ⚠️ デメリット

| デメリット | 説明 | 対策 |
|---------|------|------|
| **JOIN増加** | テーブル数が増えてJOINが複雑 | 必要に応じてビュー作成 |
| **パフォーマンス** | JOIN処理で速度が低下する場合がある | インデックス最適化 |
| **クエリ複雑化** | SQLが長く複雑になる | ストアドプロシージャ活用 |

### 実務での判断
```
✅ 正規化すべき場合:
- トランザクションデータ（注文、売上など）
- マスタデータ（顧客、商品など）
- データの整合性が重要な場合

⚠️ 非正規化を検討する場合:
- 読み取り専用のレポート用テーブル
- パフォーマンスが極端に重要
- データウェアハウス（分析用データベース）
```

---

## 6.7 実践例：ECサイトの注文管理

### ❌ 非正規形（悪い例）
```sql
CREATE TABLE orders_bad (
    order_id INT,
    order_date DATE,
    customer_name VARCHAR(100),
    customer_email VARCHAR(255),
    customer_phone VARCHAR(20),
    customer_zipcode VARCHAR(10),
    customer_address VARCHAR(500),
    product_names TEXT,              -- 'りんご,みかん,バナナ'
    product_prices TEXT,             -- '100,150,200'
    product_quantities TEXT,         -- '2,1,3'
    total_amount INT
);
```

### ✅ 第三正規形（良い例）
```sql
-- 顧客テーブル
CREATE TABLE customers (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(20),
    zipcode VARCHAR(10),
    address VARCHAR(500)
);

-- 商品テーブル
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL,
    price INT NOT NULL,
    stock_quantity INT DEFAULT 0
);

-- 注文テーブル
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    order_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'pending',
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);

-- 注文明細テーブル
CREATE TABLE order_details (
    id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    unit_price INT NOT NULL,  -- 注文時の価格を記録
    FOREIGN KEY (order_id) REFERENCES orders(id),
    FOREIGN KEY (product_id) REFERENCES products(id)
);
```

### データの整合性が保たれる例
```sql
-- 顧客の住所変更: 1箇所だけ更新すればOK
UPDATE customers SET address = '東京都新宿区...' WHERE id = 1;

-- 商品の価格変更: 過去の注文には影響しない
-- （order_details に unit_price を記録しているため）
UPDATE products SET price = 120 WHERE id = 1;

-- 注文の集計もシンプル
SELECT 
    c.name,
    COUNT(DISTINCT o.id) AS order_count,
    SUM(od.quantity * od.unit_price) AS total_amount
FROM customers c
JOIN orders o ON c.id = o.customer_id
JOIN order_details od ON o.id = od.order_id
GROUP BY c.id, c.name;
```

---

## 🎯 まとめ

| 概念 | ポイント |
|------|---------|
| **RDB** | データを表形式で管理するデータベース |
| **テーブル** | 行（レコード）と列（カラム）で構成 |
| **主キー** | レコードを一意に識別（重複・NULL不可） |
| **外部キー** | 他テーブルを参照し関連を定義 |
| **リレーション** | 1対1、1対多、多対多の関係 |
| **正規化** | データの重複を排除する設計手法 |

---

## 📝 練習問題

1. 以下のデータを格納するテーブルを設計してください
   - ブログ記事（タイトル、本文、投稿日時）
   - 記事の著者（名前、メールアドレス）
   - 記事へのコメント（コメント内容、投稿日時）

2. 上記のテーブル間の関係（リレーション）を説明してください

---

次の資料: [SQL入門](./SQL入門.md)
